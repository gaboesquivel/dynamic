---
description: React component patterns and best practices
globs: *.tsx,*.ts
alwaysApply: false
---

# React Rules

## Component Structure
- Function components only (never class components)
- No explicit return types (inferred automatically)
- Props always use object destructuring: `function Component({ title }: { title: string })`
- RORO pattern applies to regular functions only, not React components (see [TypeScript Rules](../base/typescript.mdc))

## State Management Decision Tree

1. **URL-shareable UI state** → Use `nuqs` (filters, search, tabs, pagination, view preferences)
2. **Grouped state not in URL** → Use `useSetState` from `react-use` (game engine, form state, ephemeral UI state)
3. **Loading/error states from async** → Use TanStack Query's built-in state (`isLoading`, `isError`, `isFetching`)
4. **Simple independent state** → Use `useState` (rare, prefer other options)

### nuqs for URL State
```tsx
import { useQueryState, useQueryStates, parseAsString, parseAsInteger } from 'nuqs'

const [search, setSearch] = useQueryState('q', parseAsString.withDefault(''))
const [filters, setFilters] = useQueryStates({
  search: parseAsString.withDefault(''),
  page: parseAsInteger.withDefault(1),
})
```

**Use nuqs for:** Search/filter, tabs, pagination, sort options, view preferences, shareable modal state

**Don't use nuqs for:** Game engine state, form input state, component-local UI state, frequently changing state, sensitive data

### Loading/Error State Management
Never manually manage `isLoading`, `error`, or `isError` states. Use TanStack Query hooks or `useAsyncFn` which provide these automatically.

```tsx
// ✅ Good: TanStack Query provides state
const { data, isLoading, isError, error } = useQuery(articles.all)

// ✅ Good: useAsyncFn provides state
const [saveState, saveData] = useAsyncFn(async (data) => {
  return await api.save(data)
}, [])
// Access: saveState.loading, saveState.error
```

### useSetState for Grouped State
```tsx
import { useSetState } from 'react-use'

const [state, setState] = useSetState<FormState>({
  message: '',
  signedMessage: null,
  txTo: '',
})

// Update multiple properties atomically
setState({ signedMessage: data.signedMessage, message: '' })
```

**Use for:** Multiple related state variables updated together, form state, UI state that changes together (if not URL-shareable), game/app state

**Don't use for:** URL-shareable state (use `nuqs`), loading/error states (use TanStack Query)

## Rendering Optimization
- Default to NOT using `useMemo` or `useCallback` (modern React optimizations handle most cases)
- Only use `useMemo` for computationally expensive operations
- Only use `useCallback` when:
  - Function identity required as dependency in hooks
  - Passing functions through React Context
  - Profiling reveals actual bottleneck
- Prefer `React.memo` for pure components over wrapping functions with `useCallback`

## Error Boundaries
Use `react-error-boundary` for error handling:

```tsx
import { ErrorBoundary, useErrorHandler } from 'react-error-boundary'

// Component
<ErrorBoundary FallbackComponent={ErrorFallback}>
  <YourApp />
</ErrorBoundary>

// Async errors
const handleError = useErrorHandler()
try {
  await someAsyncOperation()
} catch (error) {
  handleError(error) // Triggers nearest ErrorBoundary
}
```

**Use for:** App-level, section-level, feature-level error handling, third-party component errors

**Don't use for:** Event handlers (use try/catch), async code (use `useErrorHandler`), SSR errors

## Related Rules
- [React Hooks Rules](./react-hooks.mdc) - Data fetching patterns
- [Frontend Stack](./stack.mdc) - Library usage patterns
- [Next.js Rules](./nextjs.mdc) - Next.js-specific patterns
- [TypeScript Rules](../base/typescript.mdc) - Code style guidelines
