---
title: "ADR 002: Vencura API Framework"
description: "Decision to use Elysia as the backend API framework for its Zod-first validation, functional programming style, excellent developer experience, production performance, and AI-friendly architecture."
---

## Context

We need to select a framework for building the Vencura backend API that:

- Supports TypeScript with full type inference
- Provides **Zod-first** validation at all boundaries (requests, responses, environment variables)
- Enables **functional programming** style (no classes, no decorators, pure functions)
- Delivers **excellent developer experience** (fast feedback, intuitive API, minimal boilerplate)
- Offers **production performance** (fast runtime, efficient resource usage)
- Supports **AI-friendly** architecture (clean HTTP contracts, OpenAPI generation, typed SDKs)
- Integrates well with our monorepo structure (Bun, Vitest, ESM-native)
- Has strong ecosystem support and tooling

## Considered Options

### Option A – Elysia (Chosen)

Fast, functional, Zod-first web framework built for TypeScript and ESM.

**Pros**

- **Zod-first**: Native Zod validation built-in for requests, responses, and environment variables
- **Functional style**: Pure functions, composable plugins, route co-location - no classes or decorators
- **ESM-native**: Built for ESM from day one, works seamlessly with Bun, Vitest, and Turborepo
- **Excellent DX**: Fast feedback, intuitive API design, minimal boilerplate, excellent TypeScript inference
- **Production performance**: Fast runtime performance, efficient resource usage, suitable for high-throughput APIs
- **AI-friendly**: Auto-generated OpenAPI specs via `@elysiajs/swagger`, typed SDKs for AI tool integration
- **Type-safe contracts**: Routes consume contracts from `@vencura/types`, ensuring type safety across API, client, and frontend
- **Built-in OpenAPI**: `@elysiajs/swagger` plugin auto-generates OpenAPI from Zod + route definitions
- **Perfect testing story**: Works seamlessly with Vitest, no mocks needed, no DI boilerplate, blackbox HTTP testing via `app.handle()`
- **Lightweight**: Small, predictable primitives, minimal surface area
- **Composable**: Modular route grouping, unified error handling, typed request + response flows
- **Works with Bun**: Native Bun support for fast package management and script execution
- **Clean integration**: Perfect fit for contract-driven design with shared Zod schemas + contracts

**Cons**

- Newer framework with smaller ecosystem compared to NestJS/Express
- Less mature documentation and community resources
- WebSocket support requires additional setup (though functional patterns make it straightforward)

### Option B – Hono.js

Ultrafast web framework for the Edge.

**Pros**

- Very fast performance
- Designed for edge environments and serverless
- Lightweight and minimal
- Good TypeScript support

**Cons**

- Designed for edge/serverless, less suitable for traditional backend applications
- WebSocket support is more limited compared to Elysia
- No native Zod integration (requires plugins)
- Less mature OpenAPI generation compared to Elysia
- Newer framework with smaller ecosystem
- Less community resources and examples

### Option C – Express.js

Minimal and flexible Node.js web framework.

**Pros**

- Very flexible and unopinionated
- Large ecosystem and community
- Simple to get started
- Mature and battle-tested

**Cons**

- Minimal framework requires more boilerplate
- No built-in Zod validation (requires manual setup)
- Less opinionated, leading to inconsistent patterns
- WebSocket support requires additional libraries and setup
- No built-in OpenAPI generation (requires manual setup)
- Testing requires manual setup and mocking infrastructure
- Less TypeScript-first approach
- More manual type definitions needed
- Not ESM-native (requires additional configuration)
- Less suitable for functional programming patterns

### Option D – Fastify

Fast and low overhead web framework.

**Pros**

- Fast performance
- Low overhead
- Good TypeScript support
- Mature ecosystem

**Cons**

- Smaller ecosystem compared to Elysia for Zod-first patterns
- Less opinionated structure
- No native Zod integration (requires plugins)
- WebSocket support requires additional setup
- Less integrated compared to Elysia for our use case
- Not ESM-native (requires additional configuration)

## Decision

We will use **Elysia** as our backend API framework.

**Main reasons:**

- **Zod-first validation**: Native Zod validation built-in ensures type-safe contracts at all API boundaries, with inferred types throughout the codebase
- **Functional programming**: Pure functions, composable plugins, and route co-location align with our architectural values - no classes or decorators
- **Excellent developer experience**: Fast feedback, intuitive API design, minimal boilerplate, excellent TypeScript inference, seamless Vitest integration
- **Production performance**: Elysia's performance characteristics combined with Bun runtime deliver excellent throughput and efficient resource usage
- **AI-friendly architecture**: Clean HTTP contracts, auto-generated OpenAPI specs via `@elysiajs/swagger`, and typed SDKs (`@vencura/core`) enable seamless AI tool integration
- **ESM-native**: Built for ESM from day one, works seamlessly with Bun, Vitest, and Turborepo in our monorepo structure
- **Perfect testing story**: Works seamlessly with Vitest, no mocks needed, no DI boilerplate, blackbox HTTP testing via `app.handle()`
- **Carefully selected stack**: Elysia + Bun + Vitest + Zod + Drizzle form a cohesive, high-performance stack optimized for DX, type safety, and AI workflows

## Notes

- Elysia continues to evolve with new features and improvements
- Consider framework-agnostic patterns when building shared utilities
- Contract-first design with `@vencura/types` ensures type safety across API, client, and frontend
- Testing infrastructure leverages Vitest's blackbox testing strategy for comprehensive E2E validation
- OpenAPI generation via `@elysiajs/swagger` enables AI tool integration and typed SDK generation
- Functional patterns provide consistent, composable architecture without decorator complexity
