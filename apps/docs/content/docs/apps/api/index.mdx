---
title: "Vencura API"
description: "A multichain custodial wallet backend API built with Elysia, Zod-first validation, Dynamic authentication, and PGLite."
---

A multichain custodial wallet backend API built with **Elysia**, a fast, functional, Zod-first web framework. The API integrates with the Dynamic SDK for wallet management and transaction signing, providing a unified API for multichain operations with emphasis on **developer experience**, **production performance**, and **AI-friendly architecture**.

## Overview

Vencura is a backend API that enables users to create and manage custodial wallets across multiple blockchain networks. It provides secure wallet operations including balance queries, message signing, and transaction sending on supported chains including EVM chains (Ethereum, Arbitrum, Base, Polygon, Optimism) and Solana.

## Features

- **Multichain Support**: Create and manage wallets on multiple blockchain networks
  - **EVM Chains**: Ethereum, Arbitrum, Base, Polygon, Optimism, and all viem-supported EVM chains
  - **Solana**: Mainnet, Devnet, and Testnet
  - **Future Support**: Cosmos, Bitcoin, Flow, StarkNet, Algorand, Sui, Spark, Tron
- **Dynamic Authentication**: Secure user authentication using `@dynamic-labs/sdk-api`
- **Dynamic Wallets**: Server-side wallet management using Dynamic SDK
  - `@dynamic-labs-wallet/node-evm` for EVM chains
  - `@dynamic-labs-wallet/node-svm` for Solana
- **Custodial Wallets**: Create and manage wallets on the backend with 2-of-2 threshold signatures
- **Blockchain Operations**:
  - Get wallet balance (chain-agnostic)
  - Sign messages with wallet private keys
  - Send transactions on any supported chain
- **RPC Configuration**: Uses Dynamic's default RPC URLs with optional per-chain overrides
- **Database**: DrizzleORM with PGLite (development) or Cloud SQL Postgres (production)
- **API Documentation**: Interactive Swagger UI at `/api` (disabled by default, enable with `ENABLE_SWAGGER_UI=true`)
- **TypeScript SDK**: Auto-generated `@vencura/core` SDK from Swagger/OpenAPI specification
- **Security**:
  - AES-256-GCM encryption for private key storage
  - Rate limiting on all endpoints
  - Input validation with chain ID validation
  - Security headers (HSTS, X-Frame-Options, CSP, etc.)
  - Request size limits (10kb maximum)
  - Request ID tracing for all requests
  - Error message sanitization in production
  - Proper 429 rate limit error handling
  - Swagger UI protected by feature flag (disabled by default)
  - CORS configuration
  - DDoS protection via Cloudflare

## Tech Stack

The Vencura API uses a **carefully selected tech stack** designed for **Zod-first validation**, **functional programming**, **excellent developer experience**, **production performance**, and **AI-friendly architecture**:

- **Framework**: **Elysia** - Fast, functional, Zod-first web framework with native TypeScript support
- **Runtime**: **Bun** - Fast JavaScript runtime and package manager
- **Authentication**: Dynamic Labs SDK Client
- **Validation**: **Zod-first** - Zod schemas at all boundaries (requests, responses, environment variables)
- **Utilities**: `@vencura/lib` for error handling, async utilities, and zod utilities
- **Blockchain**:
  - Viem for EVM chains
  - @solana/web3.js for Solana
  - Dynamic SDK for wallet operations
- **Database**: Drizzle ORM with PGLite (development) or Cloud SQL Postgres (production)
- **Testing**: **Vitest** - Fast, ESM-native testing framework with blackbox testing strategy
- **API Documentation**: Swagger/OpenAPI via `@elysiajs/swagger` (generates `@vencura/core` TypeScript SDK)
- **Infrastructure**: Vercel with Google Cloud option

### Why This Stack?

- **Zod-first**: Native Zod validation built into Elysia ensures type-safe contracts at all API boundaries, with inferred types throughout the codebase
- **Functional style**: Pure functions, composable plugins, and route co-location - no classes or decorators
- **Developer experience**: Bun's fast package management and script execution, Vitest's instant feedback, and Elysia's intuitive API design
- **Production performance**: Elysia's performance characteristics combined with Bun runtime deliver excellent throughput
- **AI-friendly**: Clean HTTP contracts, auto-generated OpenAPI specs, and typed SDKs (`@vencura/core`) enable seamless AI tool integration

## Getting Started

### Prerequisites

- Bun >= 1.3.2
- Node.js >= 20

### Installation

```bash
# From monorepo root
bun install

# Or from this directory
cd apps/api
bun install
```

### Environment Variables

This API uses environment-specific configuration files. Environment files are loaded in priority order:

1. `.env` (highest priority, sensitive data, never committed, overrides everything)
2. `.env.development` / `.env.staging` / `.env.production` / `.env.test` (based on NODE_ENV, committed configs)

**File Structure:**

- `.env` - Sensitive data (API keys, tokens, secrets) - **NEVER COMMIT**
- `.env.development` - Development configuration (committed, non-sensitive) - Testnet networks
- `.env.staging` - Staging configuration (committed, non-sensitive) - Testnet networks
- `.env.production` - Production configuration (committed, non-sensitive) - Mainnet networks
- `.env.test` - Test configuration (committed, non-sensitive) - Arbitrum Sepolia testnet (for CI/CD)
- `.env-example` - Template for `.env` file (shows required sensitive variables)

**Setup for Local Development:**

```bash
# Copy the example file for sensitive data
cp .env-example .env

# Fill in your actual sensitive values in .env
# DYNAMIC_ENVIRONMENT_ID=your_environment_id
# DYNAMIC_API_TOKEN=your_api_token
# ENCRYPTION_KEY=your_32_char_encryption_key_minimum

# .env.development is already committed with non-sensitive configs
```

**Required Environment Variables:**

- `DYNAMIC_ENVIRONMENT_ID` - Dynamic Labs environment ID from the [Dynamic Dashboard](https://app.dynamic.xyz/)
- `DYNAMIC_API_TOKEN` - Dynamic Labs API token from the [Dynamic Dashboard](https://app.dynamic.xyz/)
- `ENCRYPTION_KEY` - Encryption key for private key storage (32+ characters, random string)

**Optional Environment Variables:**

- `PORT` - Server port (default: 3077)
- `RPC_URL_<CHAIN_ID>` - Per-chain RPC URL overrides (e.g., `RPC_URL_421614`, `RPC_URL_84532`)
- `ARBITRUM_SEPOLIA_RPC_URL` - Legacy Arbitrum Sepolia RPC URL (backward compatibility)
- `SOLANA_RPC_URL` - Solana RPC URL
- `OPEN_AI_KEY` - OpenAI API key for AI features
- `SENTRY_DSN` - Sentry error tracking DSN
- `SENTRY_ENVIRONMENT` - Sentry environment name
- `ENABLE_SWAGGER_UI` - Enable Swagger UI (default: `false`)
- `ARB_TESTNET_GAS_FAUCET_KEY` - Testnet faucet private key (for automated funding in E2E tests)

## Development

```bash
# Development mode (from monorepo root)
bun run dev:local  # Starts API

# Or from this directory
cd apps/api
bun run dev

# Run E2E tests
bun run test:e2e

# Lint
bun run lint

# Type check
bun run typecheck
```

The API will be available at `http://localhost:3077` (or configured port).

## API Endpoints

### Wallets

- `GET /wallets` - List all wallets for authenticated user
- `POST /wallets` - Create a new wallet
- `GET /wallets/:id` - Get wallet details
- `GET /wallets/:id/balance` - Get wallet balance
- `POST /wallets/:id/sign` - Sign a message
- `POST /wallets/:id/send` - Send a transaction

## Testing

The API uses a **blackbox Vitest testing strategy** with testnet networks:

- **Testnet-based**: Tests run against Arbitrum Sepolia testnet (Dynamic SDK doesn't support localhost chains)
- **Automated gas funding**: Wallets are auto-funded with minimum ETH using `ARB_TESTNET_GAS_FAUCET_KEY`
- **Test tokens**: Uses deployed test tokens (USDT, USDC, DNMC) on Arbitrum Sepolia
- **Blackbox testing**: All tests hit HTTP endpoints only, ensuring end-to-end validation
- **Dynamic SDK integration**: All transaction signing uses the real Dynamic SDK (no mocks)
- **Zod-first validation**: Request/response validation tested via Zod schemas from `@vencura/types`
- **Functional route testing**: Routes tested via `app.handle()` HTTP semantics, no mocks

See [API Test Documentation](./test/README.md) for complete testing strategy details.

## Architecture Principles

- **Zod-first**: All API boundaries (requests, responses, environment variables) use Zod schemas for validation and type inference
- **Functional style**: Pure functions, composable plugins, co-located routes - no classes or decorators
- **Contract-first**: Routes consume contracts from `@vencura/types` for type safety across API, client, and frontend
- **OpenAPI**: Auto-generated Swagger documentation via `@elysiajs/swagger` plugin
- **Blackbox testing**: E2E tests hit HTTP endpoints only (see [Testing](#testing))

## Related Documentation

- [Elysia Rules](../../../.cursor/rules/backend/elysia.mdc) - Elysia development patterns
- [Testing Rules](../../../.cursor/rules/backend/testing.mdc) - Testing patterns
- [TypeScript Rules](../../../.cursor/rules/base/typescript.mdc) - Type safety patterns
- [Environment Rules](../../../.cursor/rules/base/environment.mdc) - Environment variable patterns
- [Environment Strategy](/docs/environment) - Environment variable configuration
- [Deployment](/docs/deployment) - Deployment and branching strategy
- [@vencura/core](/docs/packages/core) - TypeScript SDK
- [@vencura/react](/docs/packages/react) - React hooks
- [Documentation Site](/docs) - High-level architecture and ADRs

